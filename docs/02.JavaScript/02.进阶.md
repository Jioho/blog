# JS 进阶

目录
[[toc]]

## 闭包 进阶必问！

<!-- TODO。闭包深刻理解：https://www.bilibili.com/video/BV1At41137DG?p=17 -->

**概念：**

:::tip 什么是闭包

- 闭包就是能够`读取其他函数内部变量的函数`
- 创建闭包的最常见的方式就是在`一个函数内创建另一个函数`，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域

:::

**闭包的用途**

1. 读取函数内部的变量：父函数为 f1，子函数为 f2 。f2 可以读取 f1 中的变量
2. 让这些变量的值始终保持在内存中。不会再 f1 调用后被自动清除。
3. 方便调用上下文的局部变量。利于代码封装。
   > 原因：f1 是 f2 的父函数，f2 被赋给了一个全局变量，f2 始终存在内存中，f2 的存在依赖 f1，因此 f1 也始终存在内存中，不会在调用结束后，被垃圾回收机制回收。
4. 可以让不能接收参数的方法变成可以接收参数，比如：vue 中的 `computed`

```js
export default {
  computed: {
    /**
     * 判断tab链接是否高亮
     */
    isCurrPath() {
      return (path = window.location.href) => {
        // 获取当前页面的路由。只取path。path不带任何参数。匹配
        let currHref = this.$router.history.current.path.toLowerCase()
        return path.toLowerCase().indexOf(currHref) !== -1
      }
    }
  }
}

// 使用 {{isCurrPath('url')}} 返回ture就是高亮。false就是非高亮tab
```

**先来一个题目**

```js
// fn 函数中有console 调用就会打印对应的值
// 请写出下面的输出结果
function fn(n, o) {
  console.log(o)
  return {
    fn: function(m) {
      return fn(m, n)
    }
  }
}

var a = fn(0) // 1. console = ?
a.fn(1) // 2. console = ?
a.fn(2) // 3. console = ?
a.fn(3) // 4. console = ?

var b = fn(0) // 5. console = ?
  .fn(1) // 6. console = ?
  .fn(2) // 7. console = ?
  .fn(3) // 8. console = ?

var c = fn(0).fn(1) // 9. console ? 10 .console ?
c.fn(2) // 11. console ?
c.fn(3) // 12. console ?
```

::: details 查看答案

| a 对应编号 | a 打印的值 |     | b 对应编号 | b 打印的值 |     | c 对应编号 | c 打印的值 |
| :--------: | :--------: | :-: | :--------: | :--------: | :-: | :--------: | :--------: |
|     1      | undefined  |     |     5      | undefined  |     |     9      | undefined  |
|     2      |     0      |     |     6      |     0      |     |     10     |     0      |
|     3      |     0      |     |     7      |     1      |     |     11     |     1      |
|     4      |     0      |     |     8      |     2      |     |     12     |     1      |

全对了吗？恭喜可以跳过这块了~

:::

::: details 查看解析

- a 模块

  - console - 1 ：执行 `a.fn(0)` => `o`的确不存在。返回了一个对象： `a = { fn (m) { return fn(m,0) } }`。

  > 注意 `n 被改成了 0`。 **因为内部函数可以访问外部函数的变量，理解这一点才能继续执行下去！！**

  - console - 2 ：执行 `a.fn(1)` = 执行`fn(1)` => 执行了 `fn(1,0) = [fn(m,n) 这时候的 fn是最外层的fn]` => 所以打印的 n 就是参数 0。这时候的 `O` 来自第一次执行 `a.fn(0)`

  > **因为这是闭包特性之一：内部函数可以访问外部函数的变量**，第一次执行 a.fn(0) 的 `参数n` 被保留了下来！
  >
  > **注意这里虽然有返回值，可是并没有地方接收。a 还是之前的对象**

  - console - 3 ：既然 a 没有变化。那继续执行 `a.fn(2)` = 执行 `fn(2)` => 执行了 `fn(2,0)` => 打印的还是 `0`。原因同上：n 被保留了下来！并且没有重新赋值
  - console - 4：理由同 3。n 一直没变化

- b 模块

  > > a 与 b 最大的不同在于：a 是分别调用，就算最后的 `fn(m,n)` 返回了对象，可是 a 并没有接收，a 一直都是一开始的对象:`a = { fn (m) { return fn(m,n) } }`
  > >
  > > 而 b 则是`链式调用`。上一步的返回值会被下一次调用的时候用上。直接分析代码：

  - console - 5：第一步运行 `b = fn(0)` => o 不存在，undefined。 **注意**因为是链式调用，此时 b 还没被正确赋值，返回的对象：`{ fn (m) { return fn(m,0) } }` 会直接被步骤 6 接着执行

  - console - 6：这时候执行 `fn(1)`的`fn` 来自`console-5`的返回值 => 执行 `fn(1)` 时会执行 `fn(m,n)` = 执行 `fn(1,0)` 0 也是来自第一步的 `fn(0)`。因为闭包把外部函数的 n 保留了下来。

  > 与此同时 执行`fn(1,0)` 又返回了一个对象！`{fn(m){ return fn(m,1)}}` 。变量 n = 1，在父函数(fn(1,0))传入的

  - console - 7：链式调用的原因，所以执行 `fn(2)` 的时候会接着步骤 6 返回的对象的 fn，就会执行到： `fn(2,1)` 此时的 `变量 o = 1` 来自与 console - 6 的`fn(1,0)` 。所以 输出的 `变量o` 的值便是 1。**并且 n 会被继续被改成 2**

  - console - 8：理由同上，上一步骤的 n 被修改，并且保存了下来，所以执行 `fn(3)` 相当于执行了 `fn(3,2)`。打印的值便是 2 。这时候链式调用的最后一个已经被执行完，b 被赋值为 :`{fn(m) return fn(m,3)}`。可是已经没有后续操作了，

  > b 模块结束。**注意理解为什么最后是 `fn(m,3)`。这是贯穿这一题的精髓！**

- c 模块

  > > c 模块与 a 和 b 的区别为，结合了他们 2 者的模式，既有闭包，也有链式调用，链式调用后赋值给 c。c 在继续执行了 2 次 fn

  - console - 9、console - 10：这个链式调用和 b 模块的一致，输出结果和`5,6`一致分别是`undefined`和`0`。此时的 c 被赋值为：`{fn(m){return fn(m,1)}}` 。不理解的可以重新跑一下 b 模块的 console - 8

  - console - 11：看上一步返回的 `{fn(m){return fn(m,1)}}` 所以执行 `c.fn(2)` 会接着执行 `fn(2,1)`。所以重新打印的是 `变量o = 1`。**这里 fn(2,1)虽然有返回值，可是 c 并没有接收，所以 c 并没有被修改！参照 a 模块的原理**

  - console - 12：上一步也说了。既然 c 没有被修改，那么 c 还是 `{fn(m){return fn(m,1)}}`。所以执行 `c.fn(3)`。会触发 `fn(3,1)`。打印的变量就还是 1

:::

**闭包的优缺点**

**优点**

1. 延长变量的生命周期（因为变量被子函数引用了，所以不会在父函数被调用后清除）
2. 让外部函数可以访问内部函数中的变量，因为闭包返回的方法可以赋值给外部的函数，突破作用域的限制

**缺点** ：闭包的优点也是闭包的缺点

1. 变量不会被清除，如此反复操作多次后，将会有很多的变量存在内存中，很容易就会内存溢出。需要手动清除（把变量赋值为 null）

## common.js 和 es6 中模块引入的区别？

CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。在使用上的差别主要有：

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
- CommonJs 是单个值导出，ES6 Module 可以导出多个
- CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层
- CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined

## 谈一下 JS 的类型转换

JS 的类型转换分为：`显式类型转换`、`隐式类型转换`

<!-- TODO 类型转换完善 -->

## js 中函数执行过程

1. 确定`this`的值 (确切的来说，this 在 JS 里面不是一个变量名而是一个关键字)

2. 创建一个新的`作用域`

3. 处理形参/实参（`没有定义`过才声明，无论如何都重新赋值(可能存在变量提升，提升的变量在这时候赋值)，没有对应实参则赋值为`undefined`）：

   - 对于每一个传入的实参，按照从左往右的顺序依次执行：如果对应的形参在本作用域中还没有定义，则在本作用域中声明形参，并赋值。
   - 如果已经定义过了，则重新给其赋值。(没有对应实参则赋值为"undefined"）（没有定义：就是“没有声明”的意思）

4. 处理函数定义（没有定义过才声明，无论如何都重新赋值）：

   - 对该函数中所有的定义的函数，按照代码写的顺序依次执行
   - 如果这个变量名在本作用域中还没有定义，则在本作用域中声明这个函数名，并且赋值为对应的函数
   - 如果定义了这个变量，在可写的情况下重新给这个变量赋值为这个函数，否则抛出异常。

5. 处理 `arguments`（没有定义过才声明和赋值）:
   - 如果在本作用域中没有定义 arguments，则在本作用域中声明 arguments 并给其赋值。
6. 处理变量声明（没有定义过才声明，不赋值）：

   - 对于所有变量声明，按照代码写的顺序依次执行：如果在本作用域中没有定义这个变量，则在本作用域中声明这个变量，赋值为 undefined

7. 然后执行函数代码。（当然是去变量定义里面的 var 执行）

## new 一个对象的过程中发生了什么?

1. 新生成了一个对象
2. 链接到原型
3. 绑定 this
4. 确保返回值是一个对象
5. 返回新对象

**实现一个 new**

```js
function create() {
  /**
   * 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）
   */
  let obj = {}
  /**
   * [].shift.call用法：
   * 这里是因为 arguments 并非真实数组。使用apply改变this指向，使得arguments拥有数组的方法
   * shift 返回参数的第一个值。这边接收的第一个值就是要new的对象，不能为空
   */
  let Con = [].shift.call(arguments)
  if (!Con) throw 'Object of new cannot be empty，new 的对象不能为空'
  obj.__proto__ = Con.prototype
  let result = Con.apply(obj, arguments)
  // 确保返回值为对象
  return result instanceof Object ? result : obj
}

// 调用create方法
function Test(name, age) {
  this.name = name
  this.age = age
}

Test.prototype.sayName = function() {
  console.log(this.name)
}
const test = create(Test, 'Jioho', 22)
console.log(test.name) // 'Jioho'
console.log(test.age) // 22
test.sayName() // 'Jioho'
```

## 原生 JS 如何实现继承

<!-- TODO -->

## [].shift.call(arguments) 详解

<!-- TODO -->
<!-- https://blog.csdn.net/Lockey23/article/details/76223130 -->

## JS 事件循环机制(event loop)之宏任务/微任务

::: tip 先说点基础

1. JavaScript 是单线程的语言
2. Event Loop 是 javascript 的执行机制

:::

- **javascript 事件循环**

JS 是单线程语言，意思就是同一时刻内只能执行一个任务。就好像排队，必须一个个接着来。如果上一个任务执行时间过久，那下一个任务也必须等着

那这就可能会出现问题。如果加载一个商品列表页的图片，我们必须等图片加载完才能继续加载后续的内容，整个页面都会停顿在哪里，这是绝对不允许的事情

于是出现了：`同步任务`、`异步任务`：

- 常见的`同步任务`：网页的渲染过程就是一大堆同步任务（因为 JS 也可以修改 dom。防止 JS 和 html 的渲染流程冲突）。普通的 JS 也是同步任务，因为 JS 都是一行一行执行的，上一行代码没执行完，下一行便不会执行，不过也有例外，后面会说到
- 常见的`异步任务`：ajax 请求、加载资源等耗时的任务

**看一段代码**

```js
console.log('script start')

setTimeout(function() {
  console.log('setTimeout')
}, 0)

Promise.resolve()
  .then(function() {
    console.log('promise1')
  })
  .then(function() {
    console.log('promise2')
  })

console.log('script end')
```

::: details 查看运行结果
script start -> script end -> promise1 -> promise2 -> setTimeout

`script end` 居然在第二位？没想到吧

`setTimeout` 的延迟是 0S。为什么还是最后才执行？？

`Promise` 这时候到底算是同步方法还是异步方法？
:::

来看一张图
![](https://gitee.com/Jioho/img/raw/master/knowledge/logo/20200612213711.png)

- 同步和异步任务分别进入不同的执行`场所`，同步的进入主线程，异步的进入 Event Table 并注册函数
- 当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。
- 主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。
- 上述过程会不断重复，也就是常说的 Event Loop(`事件循环`)。

> （图和解读出处：
> 作者：张倩 qianniuer
> 链接：[https://juejin.im/post/5b498d245188251b193d4059](https://juejin.im/post/5b498d245188251b193d4059)
> 来源：掘金）

- **宏任务和微任务还有 ajax**

> 同步任务很好理解。异步任务也没问题，注册回调事件嘛，我们经常这么做的。
>
> 上面代码中还有一个坑没说明，`setTimeOut` 和 `Promise`到底算怎么回事？这就要引出下面的：**宏任务（task）**，**微任务（Microtasks）**

- 宏任务：包括整体代码 script，setTimeout，setInterval、setImmediate。

- 微任务：原生 Promise(有些实现的 promise 将 then 方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver 记住就行了

- ajax 请求：`ajax 请求不属于宏任务`，js 线程遇到 ajax 请求，会将请求交给对应的 `http 线程`处理，一旦请求返回结果，就会`将对应的回调放入宏任务队列`，等请求完成执行。

- process.nextTick：`node` 中一个很重要的对象。在代码执行的过程中可以随时插入 `nextTick`，并且会保证在下一个`宏任务开始之前所执行`。

> - 在一个事件循环中，**异步事件返回结果后会被放到一个任务队列中**。然而，根据这个异步事件的类型，这个事件实际上会被对应的`宏任务队列`或者`微任务队列`中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。
>
> - 我们只需记住当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，**微任务永远在宏任务之前执行**。
>
> - 在当前的微任务没有执行完成时，是不会执行下一个宏任务的。

所以知道为啥 Promise 比 setTimeOut 先执行了把

**总结一下：**

- 宏任务按顺序执行，且浏览器在每个宏任务之间渲染页面
- 所有微任务也按顺序执行，且在以下场景（下一次宏任务之前）会立即执行所有微任务
  - 每个回调之后且 js 执行栈中为空。
  - 每个宏任务结束后。

**最后来一段代码，检验下理解程度**

```js
console.log('1')

setTimeout(function() {
  console.log('2')
  process.nextTick(function() {
    console.log('3')
  })
  new Promise(function(resolve) {
    console.log('4')
    resolve()
  }).then(function() {
    console.log('5')
  })
})
process.nextTick(function() {
  console.log('6')
})
new Promise(function(resolve) {
  console.log('7')
  resolve()
}).then(function() {
  console.log('8')
})

setTimeout(function() {
  console.log('9')
  process.nextTick(function() {
    console.log('10')
  })
  new Promise(function(resolve) {
    console.log('11')
    resolve()
  }).then(function() {
    console.log('12')
  })
})
```

::: details 查看结果
共进行了三次事件循环,完整输出为：
`1，7，6，8，2，4，3，5，9，11，10，12`

(请注意，node 环境下的事件监听依赖 libuv 与前端环境不完全相同，输出顺序可能会有误差)
:::

::: details 查看 3 次循环分析

> 第一轮

1.1. 整体的 script 进入主线程，遇到 console 1

1.2. 遇到了第一个 setTimeOut -> 分发到 `宏任务` Event Queue 中(标记为 setTimeOut1)

1.3. 遇到 process.nextTick() -> 分发到 `微任务` 中（标记为 process1）

1.4. 遇到 promise。promise 中的方法直接执行，所以会输出 7。然后进入了 `then` 回调 -> 分发到 `微任务` 中(标记为 `then1` )

1.5. 再次执行 setTimeOut。-> 分发到 `宏任务` 中。标记为(setTimeOut2)

这时候 宏任务有 2 个，微任务也有 2 个

|   宏任务    |  微任务  |
| :---------: | :------: |
| setTimeOut1 | process1 |
| setTimeOut2 |  then1   |

此时主线程已经打印了`1,7`。然后先执行所有的微任务。`process1` -> `then1`

第一轮执行结果：`1,7,6,8`

> 第二轮

第二轮时间循环从 setTimeout1 宏任务开始：

2.1 setTimeOut1 开始执行，遇到 consoole.log(2) 打印了出来

2.2 遇到了 process.nextTick -> 分发到 `微任务`(标记为 process2)

2.3 执行 Promise。其中 function 立刻执行，所以打印了 4.执行了 resolve。进入 `then` 回调，这时候 then 回调 分发到 `微任务`(标记为 then2)

这时候 setTimeOut1 已经被执行完。宏任务就剩下了 setTimeOut2.然后新增了 2 个微任务。

在执行 setTimeOut2 之前会把 2 个微任务执行完

|   宏任务    |  微任务  |
| :---------: | :------: |
| setTimeOut2 | process2 |
|             |  then2   |

所以第二轮打印的是：`2 , 4 , 3 , 5`

> 第三轮

接着执行 setTimeOut2。原理和第二轮一样。所以输出 `9，11，10，12`

拼起来就是：`1，7，6，8，2，4，3，5，9，11，10，12`

:::

## 防抖(debounce)和节流(throttle)

**概念部分**

- **防抖（debounce）**：触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

  - 输入框的 `搜索联想`，用户在不断输入值时，用防抖来节约请求资源
  - window 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
  - 如果输入框的搜索联想不添加防抖函数，用户没输入一个字符都去请求一次接口，然后重新赋值给联想输入的列表，如此反复就真的会出现`抖动`的情况，所以防抖的名称不是白叫的。感兴趣可以自行体验下~

- **节流（throttle）**：就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。

  - 鼠标不断点击触发，mousedown(单位时间内只触发一次)
  - 就好像水龙头滴水，每间隔一段时间就流下一滴

- 防抖和节流的区别：

> 假设一个场景：有一个按钮，用户在 `3s 内`，以 `0.1s 每次的速度点击`。点击按钮后会触发一个函数。函数分别用防抖和节流来处理，查看区别：

1. 防抖：因为以 `0.5S/次` 的速度点击，如果防抖控制的是每次触发时间不得小于 0.5s。那按钮最后触发的函数次数`只有 1 次`。因为前面几次点击都被重置，然后重新计算了函数执行时间。

2. 节流：节流控制的也是 `0.5s 内只执行一次`。那么 3s 后，函数会被`执行 7 次`,最后一次是因为函数没再次被销毁。

::: details demo 的实现

先通过引入 `underscore` 来使用防抖和节流

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/underscore.js/1.10.2/underscore-min.min.js"></script>
  </head>
  <body>
    <button id="btn">点击我</button>
    <script>
      let btn = document.getElementById('btn')
      var debounceFn = _.debounce(function() {
        console.log('触发防抖', new Date())
      }, 500)
      var throttleFn = _.throttle(function() {
        console.log('触发节流', new Date())
      }, 500)
      btn.addEventListener('click', debounceFn)
      btn.addEventListener('click', throttleFn)

      let allTime = 0
      let clickTime = setInterval(function() {
        if (allTime > 3000) {
          clearInterval(clickTime)
        } else {
          btn.click()
          allTime += 100
        }
      }, 100)
    </script>
  </body>
</html>
```

运行结果：
![](https://gitee.com/Jioho/img/raw/master/knowledge/logo/20200612233745.png)

:::

- 防抖函数分为非立即执行版和立即执行版。

  - 非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

  - 立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。

**通过 underscore 自己实现防抖和节流**

用到的知识点：

1. [闭包](#闭包-进阶必问！)
   1.1 防抖和节流都用到了闭包，在函数内在返回一个函数，防抖中有`timeout`。节流中有 `previous`、`timeout`。使用闭包可以确保他们多次点击触发函数的时候访问的是同一个 `timeout`

2. [apply](./01.基础.html#apply，call，bind-区别)
   2.1 apply 用于改变 this 的指向，为了兼容 es5，所以 setTimeOut 中并没有使用箭头函数，如果不用 apply 改变 this 指向，那 this 就会指向 setTimeOut 中
   2.2 函数中可能接收多个参数，参数个数是不固定的，这时候我们可以用 `arguments` 获取参数数组，而 `apply` 第二个参数刚好可以接收一个数组

3. [箭头函数拓展](./01.基础.html#箭头函数的特点)

::: details 防抖实现

```js
/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */
function debounce(func, wait, immediate) {
  let timeout

  return function() {
    let context = this
    let args = arguments

    if (timeout) clearTimeout(timeout)
    if (immediate) {
      var callNow = !timeout
      timeout = setTimeout(() => {
        timeout = null
      }, wait)
      if (callNow) func.apply(context, args)
    } else {
      timeout = setTimeout(function() {
        func.apply(context, args)
      }, wait)
    }
  }
}
```

:::

::: details 节流实现

```js
/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */
function throttle(func, wait, type) {
  let previous = 0
  let timeout
  return function() {
    let context = this
    let args = arguments
    if (type === 1) {
      let now = Date.now()

      if (now - previous > wait) {
        func.apply(context, args)
        previous = now
      }
    } else if (type === 2) {
      if (!timeout) {
        timeout = setTimeout(() => {
          timeout = null
          func.apply(context, args)
        }, wait)
      }
    }
  }
}
```

:::
