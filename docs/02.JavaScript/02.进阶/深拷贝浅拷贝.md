# 深拷贝、浅拷贝

- 浅拷贝和深拷贝都只针对于`引用数据类型`，浅拷贝只`复制指向某个对象的指针`，而不复制对象本身，**新旧对象还是共享同一块内存**
- 深拷贝会另外**创造一个一模一样的对象**，新对象跟原对象`不共享内存`，`修改新对象不会改到原对象`；

## 区别

浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制

![](https://gitee.com/Jioho/img/raw/master/knowledge/20200614234832.png)

### 没有做处理的赋值和修改

```js
// 对象赋值
var obj1 = {
  name: 'Jioho',
  age: '18',
  language: [1, [2, 3], [4, 5]]
}
var obj2 = obj1
obj2.name = 'jioho'
obj2.language[1] = ['二', '三']
obj1.age = 22
console.log('obj1', obj1) // 获取的都是一样的对象。2个对象修改是同步的
console.log('obj2', obj2) // 获取的都是一样的对象。2个对象修改是同步的
console.log(obj1 === obj2) // true
```

### 进行浅拷贝处理

```js
// Object.assgin() 就是浅拷贝，后续会说到
var obj1 = {
  name: 'Jioho',
  age: '18',
  language: [1, [2, 3], [4, 5]]
}
var obj2 = Object.assign({}, obj1)
obj2.name = 'jioho'
obj2.language[1] = ['二', '三']
obj1.age = 22
console.log('obj1', obj1)
console.log('obj2', obj2)
console.log(obj1 === obj2) // false

// 第二层的属性，用全等判断还是true。说明内存地址还是一样的
console.log(obj1.language === obj2.language) // true
```

![](https://gitee.com/Jioho/img/raw/master/knowledge/20200614235647.png)

### 进行深拷贝

```js
// 常用的方法是JSON.stringify + JSON.parse
var obj1 = {
  name: 'Jioho',
  age: '18',
  language: [1, [2, 3], [4, 5]]
}
var obj2 = JSON.parse(JSON.stringify(obj1))
obj2.name = 'jioho'
obj2.language[1] = ['二', '三']
obj1.age = 22
console.log('obj1', obj1)
console.log('obj2', obj2)
console.log(obj1 === obj2) // false
console.log(obj1.language === obj2.language) // false
```

![](https://gitee.com/Jioho/img/raw/master/knowledge/20200615000343.png)

**结论**

|  操作  | 和原数据是否指向同一对象 | `第一层数据`为基础数据类型 |      原数据包含子对象      |
| :----: | :----------------------: | :------------------------: | :------------------------: |
|  赋值  |            是            |    改变使原数据一同改变    |       子对象一同改变       |
| 浅拷贝 |            否            |     第一层的原数据不变     | 原子对象会和新对象一起改变 |
| 深拷贝 |            否            |         原数据不变         |         原数据不变         |

## 深拷贝

<!-- TODO。完善深拷贝 -->
<!-- https://juejin.im/post/5b5dcf8351882519790c9a2e#heading-4 -->
