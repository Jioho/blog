# JS 基础

**目录**

[[toc]]

## js 的数据类型

- 8 种数据类型
  `undefined`、`Null`、`Boolean`、`Number`、`String`、`BigInt`、`Symbol`
- 和引用数据类型 `Object`

::: danger

- 数据类型又分为`基本数据类型`和`引用数据类型`
- 基本类型值：指的是保存在**栈内存**中的简单数据段
- 引用数据类型：保存在**堆内存**中的对象 `Object`
- 使用 `typeof` 可以直接检测对应的数据类型
  :::

## js 的基本数据类型

`undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`

- 基本数据类型都是存储在 **栈内存** 中

## js 有几种类型的值,他们之前的区别

- js 分为 `基础数据类型` 和 `引用数据类型`

- 区别:
  1. 存储位置不同
     - 基础数据类型(6 种) 存在栈内存中
     - 引用数据类型：存在堆内存中
  2. 大小和存放的区别
     - 基础数据类型：占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储
     - 引用数据类型： 占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其索引

## js 的内置对象有哪些

> 内置对象概念：js 已经创建好了，你不用自己再创建的对象（免去 new 的步骤），直接就可以调用

- 其他对象：`Function`、`Arguments`、`Math`、`Date`、`RegExp`、`Error`
- 数据封装类对象：`Object`、`Array`、`Boolean`、`Number` 和 `String`

## null，undefined 的区别

- `null`

  1. 表示一个对象被定义了，值为“空值”
  2. 是一个对象(空对象, 没有任何属性和方法)

- `undefined`

  1.  表示不存在这个值。
  2.  是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 `undefined`
  3.  例如变量被声明了，但没有赋值时，就等于 `undefined`

---

- null 表示一个值被定义了，定义为“空值”；
- undefined 表示根本不存在定义。
- 所以设置一个值为 null 是合理的，如 objA.valueA = null;
- 但设置一个值为 undefined 是不合理的

```js
typeof null // object
typeof undefined // undefined
null == undefined // true
null === undefined // false
```

::: danger
在验证 `null` 时，一定要使用　`===` ，因为 `==`无法分别 `null` 和 `undefined`
:::

## 创建对象的几种方式

1. 对象字面量的方式
2. 用 `function` 来模拟无参的构造函数
3. 用 `function` 来模拟参构造函数来实现（用 `this` 关键字定义构造的上下文属性）
4. 用工厂方式来创建（内置对象）
5. 用原型方式来创建
6. 用混合方式来创建

::: details 查看详细的创建代码

1. 对象字面量

```js
let person = { name: 'Jioho', sex: 'man', age: 22 }
```

2. 用 `function` 来模拟无参的构造函数

```js
function Person() {}
// 定义一个function，如果使用new"实例化"
// 该function可以看作是一个Class
var person = new Person()
person.name = 'Jioho'
person.age = '22'
person.work = function() {
  console.log(this.name + ' is codinig')
}
person.work() // jioho is coding
```

3. 用 function 来模拟参构造函数来实现

```js
// 用this关键字定义构造的上下文属性
function Person(name, age, skill) {
  this.name = name //this作用域：当前对象
  this.age = age
  this.skill = skill
  this.word = function() {
    console.log(this.name + ' skill is ' + this.skill)
  }
}

//实例化、创建对
var author = new Person('Jioho', 25, 'coding')象
author.word() // Jioho skill is coding
```

4. 用工厂方式来创建（内置对象）

```js
var dog = new Object()
dog.name = '旺财'
dog.age = 3
dog.shout = function() {
  console.log('我是' + wcDog.name + ',汪汪汪......')
}
dog.shout()
```

5. 用原型方式来创建

```js
function Dog() {}
Dog.prototype.name = '旺财'
Dog.prototype.shout = function() {
  console.log('我是' + wcDog.name + ',汪汪汪......')
}
var wangcai = new Dog()
wangcai.shout()
```

6. 用混合方式来创建

```js
function Car(name, price) {
  this.name = name
  this.price = price
}
Car.prototype.sell = function() {
  console.log('我是' + this.name + '，我现在卖' + this.price + '万元')
}
var camry = new Car('凯美瑞', 27)
camry.sell()
```

:::

## let var const 区别

- 作用域

  - `let` 作用域被限制在块级中的变量、语句或者表达式
  - `var` 作用域限制在其声明位置的上下文中，而非声明变量总是全局的
  - `const` 声明创建一个值的只读引用 (即指针)

- 变量提升

  - `let` 不存在变量提升，存在暂时性死区，咋子赋值之前使用该变量会报错
  - `var` 存在变量提升，如果在变量赋值之前使用该变量拿到的值是 undefined
  - `const` 不存在变量提示，提前使用变量会报错

::: details 查看变量提升的示例

```js
;(function() {
  console.log(testLet) // Cannot access 'testLet' before initialization
  console.log(testVar) // undefined
  console.log(testConst) // Uncaught ReferenceError: Cannot access 'testConst' before initialization
  let testLet = 'testLet'
  var testVar = 'testVar'
  const testConst = 'testConst'
})()
```

:::

- 可变性

  - `let` 变量可以重新赋值
  - `var` 变量可以重新赋值
  - `const` 变量不可变，如果变量是复合类型（对象），改变复合对象中的某一项可以改变

```js
const anthor = { name: 'Jioho' }
anthor = 'Jioho' // Uncaught TypeError: Assignment to constant variable
anthor.name = 'Jioho_chen' // 成功
```

::: tip let、var 、const 使用

1. let 命令不存在变量提升，如果在 let 前使用 var，会导致报错
2. 如果块区中存在 let 和 const 命令，就会形成封闭作用域
3. 不允许重复声明，因此，不能在函数内部重新声明参数

::: details 查看示例

```js
function fn() {
  var _fn = 1
  var _fn = 2
  console.log(_fn) // 2
}

// 报错理由：3 - 不允许重复声明
function fn() {
  // 报错
  let _fn = 1
  let _fn = 2

  // 报错
  const _fn = 1
  const _fn = 2

  // 报错
  let _fn = 1
  var _fn = 2
}

// 报错理由：3 - 不允许重复声明
function fn(name) {
  // 报错
  let name = 'Jioho'
  const name = 'Jioho'

  // 正常访问！
  var name = 'Jioho'

  // 正常访问
  let a = () => {
    let name = 'Jioho'
  }
}

function fn() {
  let name = 'Jioho'
  const anthor = name

  console.log(name, anthor)
}
```

:::


## 描述一下 `this`

::: tip this

1. 函数执行的上下文，可以通过 apply，call，bind 改变 this 的指向。
2. 对于匿名函数或者直接调用的函数来说，this 指向全局上下文（浏览器为 window，NodeJS 为 global），剩下的函数调用，那就是谁调用它，this 就指向谁。
3. 当然还有 es6 的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，this 就指向哪里

:::

<!-- 数据类型检测之typeof详解 https://blog.csdn.net/wu_xianqiang/article/details/70176587 -->
