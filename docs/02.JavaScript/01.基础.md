# JS 基础

**目录**

[[toc]]

## 原型和原型链-基础,但是非常重要

> - 我们创造的每一个函数都有一个 `prototype（原型）属性`。这个属性是一个指针，指向原型对 象。在默认情况下，所有的`原型对象都会有一个 constructor(构造函数）属性`，这个属性包含一个指向 prototype 属相所在的指针。当调用构造函数创建一个新实例之后，该实例内部将包含一个指针（内部属性），指向构造函数的原型对象。
>
> - 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去 prototype 里找这个属性，这个 `prototype 又会有自己的 prototype`，于是就这样`一直找下去`，也就是我们平时所说的`原型链`的概念

**简单总结：**

- prototype 是一个对象的`原型`
- prototype(原型其实也是一个对象，那对象就还有他自己的原型) 找 prototype 如此下去的关系链，称为原型链
- 抽象为代码就是：`instance.constructor.prototype = instance.__proto__`
- 原型链最顶端是 `null`。

**1. 原型（最下面有流程图，字不如图好理解，不过字一定要看完）**

要了解以下概念：`__proto__`、`prototype`、`普通对象`、`函数对象（内置对象）`

> 不清楚 `普通对象`和`函数对象`？看这里[内置对象有哪些-内置对象-函数对象-和普通对象区别](#内置对象有哪些-内置对象-函数对象-和普通对象区别)

| 对象类型 | `__proto__` | `prototype` |
| :------: | :---------: | :---------: |
| 普通对象 |     ✅      |     ❌      |
| 函数对象 |     ✅      |     ✅      |

**1.1 结论：**

- 只有函数对象有 `prototype` 属性，普通对象 没有这个属性。
- `prototype` 和 `__proto__`都是在创建一个函数或者对象会自动生成的属性。

用代码验证下结论：

```js
//func称为构造函数
function func() {}
console.log(typeof func.prototype) // object
console.log(typeof func.__proto__) // function

const obj = {}
console.log(typeof obj.__proto__) //object
console.log(typeof obj.prototype) //undefined （看见了吧，普通对象真的没有 prototype 属性）
```

再看一段代码

```js
console.log(obj.__proto__ === Object.prototype) // true
console.log(func.__proto__ === Function.prototype) // true
console.log(func.constructor.prototype === func.__proto__) // true

// native code的意思就是浏览器内置的函数。又涉及到内置函数，不懂得一定要看懂
console.log(func.__proto__) // ƒ () { [native code] }
console.log(func.constructor) // ƒ Function() { [native code] }
console.log(func.prototype) // {constructor:{},__proto__:{}}
```

**1.2 结论**

- 实例的 `__proto__` 属性主动指向`构造的 prototype`;
- `prototype` 属性被 `__proto__` 属性 所指向。
- 这就是原型和原型链的关联：原型不断找到他上一级的原型，找的过程形成的链条就是原型链。而`__proto__`就是 2 个节点中的链条

---

那么问题来了，既然 `func` 是一个函数对象，函数对象是有 `prototype` 属性的，那么 `func.prototype.__proto__`等于啥呢？
验证一下：

```js
function func() {}
console.log(typeof func.prototype) // object
console.log(func.prototype.__proto__ === Object.prototype) //true
```

**1.3 结论**

- `func.prototype` 是一个对象
- 既然是对象，那么他的原型就是 `Object.prototype`
- 所以当创建一个构造函数的时候，JS 自动执行了下面的代码：

```js
//我们手动创建func函数
function func() {}
//javascript悄悄咪咪执行以下代码:
func.__proto__ = Function.prototype //实例的 __proto__ 属性主动指向构造的 prototype
func.prototype = {
  constructor: func,
  __proto__: Object.prototype //我们刚刚才在上面验证的，你别又忘记了
}
```

基于上面的结论，画了一张图：（PS：这只是入门级的第一步图，这个图一定要记清楚，后面的图会更复杂）

new 原理不懂的可以看这里:[new-一个对象的过程中发生了什么](./02.进阶.html#new-一个对象的过程中发生了什么)

> 图中的步骤已经标清楚，可以根据步骤一点点看，而不是一下子看到那么大的流程图无从入手

![](https://gitee.com/Jioho/img/raw/master/knowledge/20200614181608.png)

**2. 原型链**

> 上图中已经体现出一些原型链的东西:
>
> `func`--`__proto__`-->`Function.prototype` --`__proto__`-->`Object.prototy`--`__proty__`--> `null`

**这样的链条，有什么作用呢？用处体现在哪里？**


来看这段代码：

```js
// 定义一个动物对象
function Animal(name, age) {
  this.name = name
  this.age = age
  this.home = '宠物店'
}

Function.prototype.functionSay = function() {
  console.log('调用了Function - say方法')
}

Object.prototype.objectSay = function() {
  console.log('调用了Object - say方法')
}

Animal.prototype.eat = function() {
  console.log(this.name + ' Eating')
}
Animal.prototype.run = function() {
  console.log(this.name + ' running')
}

const dog = new Animal('旺财', 1) // 创建一个动物对象
console.log(dog) // Animal:{name:'旺财',age:1,home:'宠物店'}
dog.eat() // 旺财 Eating
dog.run() // 旺财 running
dog.sayHello() // Uncaught TypeError: dog.sayHello is not a function
console.log(dog.name) // 旺财
console.log(dog.sex) // undefined
console.log(dog.home) // 宠物店

const cat = new Animal('咪咪', 2)
cat.sayHello = function() {
  console.log('Hello,my name is ' + this.name)
}
cat.eat() // 咪咪 Eating
cat.eat = function() {
  console.log(this.name + ' 在吃猫粮')
}
cat.eat() // 咪咪 在吃猫粮
cat.sayHello() // Hello,my name is 咪咪

const bosi = new cat() // Uncaught TypeError: cat is not a constructor

// Cannot set property 'play' of undefined
cat.prototype.play = function() {
  console.log(this.name + ' playing')
}

dog.objectSay() // 打印了什么？
cat.functionSay() // 打印了什么？

cat.__proto__.sleep = function() {
  console.log(this.name + ' sleeping')
}

dog.sleep() // 旺财 sellpinig
```

以下问题从 JS 的原型和原型链原理解答：全部答对，说明原型和原型链已经过关了

::: details dog 为什么会有`eat` 和 `run` 方法？

- dog 对象是从 `new Animal` 得来。根据 new 的原理，`Animal`是一个构造函数，接收 2 个参数，所以为 dog 对象赋值了 `name` 和 `age`。并且 `Animal` 是`函数对象`。拥有`protorype`属性，`eat`。`run` 方法都挂载在了 `protorype`上。
- 调用 `dog.eat` 的时候，会先查询 dog 对象是否存在 eat 方法（不存在）。于是就往原型链上面找：`dog.__proto__.eat`
- 由于`dog.__proto__ === Animal.prototype`。最后调用到了 `Animal.prototype.eat()`。`run` 同理

:::

::: details dog 调用 sayHello 为什么会报错？

- 理由和 1 差不多，在 dog 自身对象上找，`找不到 sayHello` 。往原型链上找，最后找到原型链顶端`null`。执行 `null.sayHello()` 自然就报错：dog.sayHello is not a function

:::

::: details dog 的`home`是从哪里来的？

- dog 自身并不存在 `home`属性。于是在 Animal 对象上找到了 Home 属性。这个称之为`继承`。new 出来的对象中 继承了 Animal 的所有属性和方法

:::

::: details cat 能调用 `sayHello`？

- 因为 cat 对象在创建后，在 cat 对象上赋值了一个 sayHello 方法。调用方法的时候第一个就找到了 cat 上的方法，所以就可以执行

:::

::: details cat 2 次 `eat` 方法为什么不一样？

- 第一次执行：第一次执行，cat 方法还没挂载 eat 方法。于是找到原型链上的 eat
- 第二次执行：这时候 cat 已经挂载了 eat 方法，所以就直接执行自己的 eat 方法，这成为 `方法重写`

:::

::: details `new cat` 为什么会报错？错在哪里？

- new 的操作实际上是`被new的对象的prototype`复制给新的对象的`__proto__`。这时候的 `cat` 只是一个`对象`。对象不存在`prototype` 对象。所以就 new 失败了

:::

::: details 为什么不能在 cat 的 `prototype` 上挂载方法？

- cat 只是一个对象，new Animal 生成的一个对象，对象不存在 `prototype`属性。

:::

::: details dog 为什么可以调用 `sleep`?

- 首先，`cat.__proto__` 挂载了一个 `sleep` 方法。`cat.__proto__ === Animal.prototype` 。相当于 sleep 挂载在了 Animal 的原型上（当然极度不推荐这么去用）
- dog.sleep 调用的时候，自身没有 sleep 方法。在原型上（Animal）中找到了。所以就可以调用

:::

::: details 最后 objectSay、functionSay 方法打印了什么?为什么

- objectSay 打印了 `调用了Object - say方法`
- functionSay 报错：`Uncaught TypeError: cat.functionSay is not a function`

因为根据原型链，dog 上没有 `objectSay、functionSay`。就到 `Animal` 上找,`Animal`上也没有这 2 个方法。就继续往上一层去找 `Animal.__proto__` === `Object.protytype`。找到了 Object 上有 `objectSay` 方法，调用成功，而 `functionSay` 还没找到。继续找 `Object.__proto__`，原型链顶层是`null`、于是还没找到 `functionSay`。最后报错

:::

## js 的数据类型

- 8 种数据类型
  `undefined`、`Null`、`Boolean`、`Number`、`String`、`BigInt`、`Symbol`
- 和引用数据类型 `Object`

::: danger 重点

- 数据类型又分为`基本数据类型`和`引用数据类型`
- 基本类型值：指的是保存在**栈内存**中的简单数据段
- 引用数据类型：保存在**堆内存**中的对象 `Object`
- 使用 `typeof` 可以直接检测对应的数据类型
- 基本数据类型不是对象

:::

## js 的基本数据类型

`undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`

- 基本数据类型都是存储在 **栈内存** 中
- 注意这些都是基础数据类型，而`不是对象`

## 数据类型有几种类型,他们之前的区别

- js 分为 `基础数据类型` 和 `引用数据类型`

- 区别:

  1. 存储位置不同

     - 基础数据类型(6 种) 存在栈内存中
     - 引用数据类型：存在堆内存中

  2. 大小和存放的区别

     - 基础数据类型：占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储
     - 引用数据类型： 占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其索引

## 判断数据类型：typeof 和 instanceof

::: tip typeof

- `typeof` 对于基本类型，除了 `null` 都可以显示正确的类型
- `typeof` 对于对象，除了函数都会显示 `object`
- 主要用于判断数据是不是基本数据类型：`String`、`Number`、`Object`、`Null`、`Undefined`，但是无法判断出 function（有些浏览器会出错）、array、regExp

```js
console.log(typeof '') // string
console.log(typeof []) // object
console.log(typeof {}) // object
console.log(typeof 1) // number
console.log(typeof null) // object
console.log(typeof undefined) // undefined
console.log(typeof true) // boolean
console.log(typeof function() {}) // function
console.log(typeof /\d/) // object
```

:::

::: tip instanceof

- 主要的目的是用来检测`引用类型`，判断 `Array` 和 `RegExp`，无法准确判断 Function
- `A对象 instanceof B对象` : 判断 A 对象原型链上 是否有 B 对象原型 ！！！
- `instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`

```js
console.log([] instanceof Array) //true
console.log({} instanceof Object) //true
console.log(/\d/ instanceof RegExp) //true
console.log(function() {} instanceof Object) //true
console.log(function() {} instanceof Function) //true

console.log('' instanceof String) //false
console.log(1 instanceof Number) //false
```

:::

::: tip Object.prototype.toString
这是对象的一个原生原型扩展函数，用来精确的区分数据类型

```js
var type = Object.prototype.toString
console.log(type.call('')) // [object String]
console.log(type.call([])) // [object Array]
console.log(type.call({})) // [object Object]
console.log(type.call(false)) // [object Boolean]
console.log(type.call(null)) // [object Null]
console.log(type.call(undefined)) // [object Undefined]
console.log(type.call(function() {})) // [object Function]
```

:::

## 内置对象有哪些?内置对象(函数对象)和普通对象区别

> 内置对象概念：js 已经创建好了，你不用自己再创建的对象（免去 new 的步骤），直接就可以调用

- 其他对象：`Function`、`Arguments`、`Math`、`Date`、`RegExp`、`Error`
- 数据封装类对象：`Object`、`Array`、`Boolean`、`Number` 和 `String`

::: danger 重点

- 这些都是`函数对象`，他们同时也被称为`内置对象`。函数对象本身`其实就是一个纯函数`，javascript 用他们来模拟类。

- 普通对象就很简单了，就是我们常见的对象:

```js
const obj = {
  name: 'Jioho',
  age: 22
}
```

- 理解函数对象非常重要，理解了这个才能理解 [原型和原型链](#原型和原型链-基础-但是非常重要)

:::

**在深入了解下：`函数对象`和`普通对象`**

```js
const obj1 = {}
const obj2 = new Object()
function func1() {}
const obj3 = new func1()
const func2 = new (function() {})()
const func3 = new Function()
const time = new Date()

// 分别打印一下
console.log(typeof obj1) // object
console.log(typeof obj2) // object
console.log(typeof obj3) // object
console.log(typeof func1) // function
console.log(typeof func2) // object
console.log(typeof func3) // function
console.log(typeof time) // object
console.log(typeof Date) // function
```

- 所以可以看见,`obj1`、`obj2`、,`obj3` 是`普通对象`，他们都是 `Object 的实例`，而 `func1`、`func3`、`Date` 则都是 Function 的实例，称为函数对象。

- 有几个特殊的 `func2`和`time`。通过 new 关键字后，变成了 `object` 普通对象。原理可以看 [new 一个对象的过程中发生了什么?](./02.进阶.html#new-一个对象的过程中发生了什么)

- `结论：`

  - 只要是 `Function` 的实例，那就是`函数对象`，其余则为`普通对象`

> 我们从上面可以看出，一个对象是通过构造函数 new 出来的，这其实跟原型和原型链有很大的关系，那么原型和原型链到底是用来干嘛的呢？可以重温下：[原型和原型链](#原型和原型链-基础-但是非常重要)

## null，undefined 的区别

- `null`

  1. 表示一个对象被定义了，值为“空值”
  2. 是一个对象(空对象, 没有任何属性和方法)

- `undefined`

  1.  表示不存在这个值。
  2.  是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 `undefined`
  3.  例如变量被声明了，但没有赋值时，就等于 `undefined`

---

- null 表示一个值被定义了，定义为“空值”；
- undefined 表示根本不存在定义。
- 所以设置一个值为 null 是合理的，如 objA.valueA = null;
- 但设置一个值为 undefined 是不合理的

```js
typeof null // object
typeof undefined // undefined
null == undefined // true
null === undefined // false
```

::: danger
在验证 `null` 时，一定要使用　`===` ，因为 `==`无法分别 `null` 和 `undefined`
:::

## == 和 ===区别，什么情况用 ==

1. == 叫做 `相等运算符` ，=== 叫做 `严格运算符`
2. 使用 `==` 的时候，如果 2 边的值类型不一致，会自动转换为同一类型在比较
   `如： 1 == '1' // true`
3. 使用 `===` 的时候，不会进行类型转换，必须类型一致，值也一致，才返回 true

## 创建对象的几种方式

1. 对象字面量的方式
2. 用 `function` 来模拟无参的构造函数
3. 用 `function` 来模拟参构造函数来实现（用 `this` 关键字定义构造的上下文属性）
4. 用工厂方式来创建（内置对象）
5. 用原型方式来创建
6. 用混合方式来创建

::: details 查看详细的创建代码

1. 对象字面量

```js
let person = { name: 'Jioho', sex: 'man', age: 22 }
```

2. 用 `function` 来模拟无参的构造函数

```js
function Person() {}
// 定义一个function，如果使用new"实例化"
// 该function可以看作是一个Class
var person = new Person()
person.name = 'Jioho'
person.age = '22'
person.work = function() {
  console.log(this.name + ' is codinig')
}
person.work() // jioho is coding
```

3. 用 function 来模拟参构造函数来实现

```js
// 用this关键字定义构造的上下文属性
function Person(name, age, skill) {
  this.name = name //this作用域：当前对象
  this.age = age
  this.skill = skill
  this.word = function() {
    console.log(this.name + ' skill is ' + this.skill)
  }
}

//实例化、创建对
var author = new Person('Jioho', 25, 'coding')象
author.word() // Jioho skill is coding
```

4. 用工厂方式来创建（内置对象）

```js
var dog = new Object()
dog.name = '旺财'
dog.age = 3
dog.shout = function() {
  console.log('我是' + wcDog.name + ',汪汪汪......')
}
dog.shout()
```

5. 用原型方式来创建

```js
function Dog() {}
Dog.prototype.name = '旺财'
Dog.prototype.shout = function() {
  console.log('我是' + wcDog.name + ',汪汪汪......')
}
var wangcai = new Dog()
wangcai.shout()
```

6. 用混合方式来创建

```js
function Car(name, price) {
  this.name = name
  this.price = price
}
Car.prototype.sell = function() {
  console.log('我是' + this.name + '，我现在卖' + this.price + '万元')
}
var camry = new Car('凯美瑞', 27)
camry.sell()
```

:::

## let var const 区别

- 作用域

  - `let` 作用域被限制在块级中的变量、语句或者表达式
  - `var` 作用域限制在其声明位置的上下文中，而非声明变量总是全局的
  - `const` 声明创建一个值的只读引用 (即指针)

- 变量提升

  - `let` 不存在变量提升，存在暂时性死区，咋子赋值之前使用该变量会报错
  - `var` 存在变量提升，如果在变量赋值之前使用该变量拿到的值是 undefined
  - `const` 不存在变量提示，提前使用变量会报错

::: details 查看变量提升的示例

```js
;(function() {
  console.log(testLet) // Cannot access 'testLet' before initialization
  console.log(testVar) // undefined
  console.log(testConst) // Uncaught ReferenceError: Cannot access 'testConst' before initialization
  let testLet = 'testLet'
  var testVar = 'testVar'
  const testConst = 'testConst'
})()
```

:::

- 可变性

  - `let` 变量可以重新赋值
  - `var` 变量可以重新赋值
  - `const` 变量不可变，如果变量是复合类型（对象），改变复合对象中的某一项可以改变

```js
const anthor = { name: 'Jioho' }
anthor = 'Jioho' // Uncaught TypeError: Assignment to constant variable
anthor.name = 'Jioho_chen' // 成功
```

::: tip let、var 、const 使用

1. let 命令不存在变量提升，如果在 let 前使用 var，会导致报错
2. 如果块区中存在 let 和 const 命令，就会形成封闭作用域
3. 不允许重复声明，因此，不能在函数内部重新声明参数

::: details 查看示例

```js
function fn() {
  var _fn = 1
  var _fn = 2
  console.log(_fn) // 2
}

// 报错理由：3 - 不允许重复声明
function fn() {
  // 报错
  let _fn = 1
  let _fn = 2

  // 报错
  const _fn = 1
  const _fn = 2

  // 报错
  let _fn = 1
  var _fn = 2
}

// 报错理由：3 - 不允许重复声明
function fn(name) {
  // 报错
  let name = 'Jioho'
  const name = 'Jioho'

  // 正常访问！
  var name = 'Jioho'

  // 正常访问
  let a = () => {
    let name = 'Jioho'
  }
}

function fn() {
  let name = 'Jioho'
  const anthor = name

  console.log(name, anthor)
}
```

:::

## 描述一下 `this`

1. 函数执行的上下文，可以通过 `apply`，`call`，`bind` 改变 this 的指向。
2. 对于匿名函数或者直接调用的函数来说，this 指向全局上下文（浏览器为 window，NodeJS 为 global），剩下的函数调用，那就是谁调用它，this 就指向谁。
3. 当然还有 es6 的箭头函数，`箭头函数`的指向取决于该箭头函数声明的位置，在哪里声明，this 就指向哪里

## `apply`，`call`，`bind` 区别

1. `call` 和 `apply` 都是为了解决改变 `this` 的指向。作用都是相同的，只是传参的方式不同
2. 除了第一个参数外，`call` 可以接收一个参数列表，`apply` 只接受一个参数数组
3. `bind` 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并不会立刻执行

## 箭头函数的特点

```js
function fn() {
  return () => {
    return () => {
      console.log(this)
    }
  }
}
console.log(fn()()())
```

::: tip

- 箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 fn 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变

- 由于箭头函数没有自己的 this，所以当然也就不能用 call()、apply()、bind()这些方法去改变 this 的指向。

:::

## 数组用法总结

JS 中很多操作都可以转换为数组很方便的完成，数组又分为：`改变原数组的方法`和`不改变原数组的的方法`。

**改变原数组的方法**

::: details splice - 添加/删除数组元素

- 语法：

```js
var arr = []
arr.splice(index,howmany,item1,.....,itemX)
```

- 参数:
  1.index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
  2.howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。
  3.item1, ..., itemX：可选。向数组添加的新项目。

- 返回值: 如果有元素被删除,返回包含被删除项目的新数组。

:::

::: details sort 数组排序

- 语法：

```js
var arr = []
arr.sort(function(a, b) {
  return a - b
})
```

- 参数:
  1.sortby 可选。规定排序顺序。必须是函数。。

- 返回值: 返回包排序后的新数组。

:::

::: details pop 删除数组最后的一个元素

- 语法

```js
var arr = []
arr.pop()
```

- 参数 无

- 返回值 被删除的元素

:::

::: details shift 删除数组第一项

- 语法

```js
var arr = []
arr.shift()
```

- 参数 无

- 返回值 被删除的元素

:::

::: details push 往数组后添加内容

- 语法

```js
var arr = []
arr.push(item,item1,item2....,itemx)
```

- 参数

  1. item 必填 需要添加的第一项元素
  2. item1-itemx 可选，需要添加的后续的元素

- 返回值：`新的数组长度`

:::

::: details unshift 往数组第一项开始添加内容

- 语法

```js
var arr = []
arr.unshift(item,item1,item2....,itemx)
```

- 参数

  1. item 必填 需要添加的第一项元素
  2. item1-itemx 可选，需要添加的后续的元素

- 返回值：`新的数组长度`

:::

::: details reverse 反转数组

- 语法

```js
var arr = []
arr.reverse()
```

- 参数：无

- 返回值 颠倒后的新数组。

:::

::: details copyWithin 指定位置的成员复制到其他位置

- 语法

```js
var arr = []
arr.copyWithin(target, start, end)
```

- 参数

  1. target 从该位置开始插入复制的数据
  2. start 复制的数据的数据源开始的索引。默认是 0 数组的第一项开始复制
  3. end 复制的数据源的结束位置，默认是 arr.length 数组的最后一项

  以上参数可为负数，负数则代表从该位置反过来数

- 返回值：返回当前数组

:::

::: details fill 填充数组

- 语法

```js
// 假设有一个长度为10的数组。默认值都是空，则可以通过 fill方法填充默认值
var arr = []
arr.length = 10
arr.fill(value, start, end)
```

- 参数

  1. value 需要填充的数据 必须
  2. start 从指定的索引开始填充 可选，默认是 0
  3. end 到指定索引结束 可选。默认是数组的长度

- 返回值：返回填充后的数组

:::

**不改变原数组的方法**

::: details slice 浅拷贝数组的元素

- 语法

```js
var arr = []
arr.slice(begin, end)
```

- 参数

  1. begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为 0。
  2. end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。

- 返回值：返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。

:::

::: details join 数组转字符串

- 语法

```js
var arr = []
arr.join(str)
```

- 参数

  1. str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。

- 返回值:返回生成的字符串。

:::

::: details concat 合并两个或多个数组

- 语法

```js
var arr = []
var arr2 = []
var newArr = arr.concat(arr2,arr3...arrn)

```

- 参数

  1. arr2（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。

- 返回值 返回返回合并后的新数组。

:::

::: details indexOf 查找数组是否存在某个元素

- 语法

```js
var arr = []
arr.indexOf(search, fromIndex)
```

- 参数

  1. search (必须):被查找的元素
  2. fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为 0。

- 返回值 返回下标。如果没有对应的值返回 -1

:::

::: details lastIndexOf 查找指定元素在数组中的最后一个位置

- 语法

```js
var arr = []
arr.lastIndexOf(search, fromIndex)
```

- 参数

  1. searchElement(必须): 被查找的元素
  2. fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。

- 返回值 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）

:::

::: details includes 查找数组是否包含某个元素

- 语法

```js
var arr = []
arr.includes(search, fromIndex)
```

- 参数

  1. searchElement(必须):被查找的元素
  2. fromIndex(可选):默认值为 0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回 false。负值绝对值超过长数组度，重置从 0 开始搜索。

- 返回值 返回布尔

:::

## 立即执行函数

::: tip 作用
声明一个匿名函数，马上调用这个`匿名函数`。`目的是保护内部变量不受污染`。
:::
