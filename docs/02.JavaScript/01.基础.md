# JS 基础

**目录**

[[toc]]

## js 的数据类型

- 8 种数据类型
  `undefined`、`Null`、`Boolean`、`Number`、`String`、`BigInt`、`Symbol`
- 和引用数据类型 `Object`

::: danger

- 数据类型又分为`基本数据类型`和`引用数据类型`
- 基本类型值：指的是保存在**栈内存**中的简单数据段
- 引用数据类型：保存在**堆内存**中的对象 `Object`
- 使用 `typeof` 可以直接检测对应的数据类型
  :::

## js 的基本数据类型

`undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`

- 基本数据类型都是存储在 **栈内存** 中

## js 有几种类型的值,他们之前的区别

- js 分为 `基础数据类型` 和 `引用数据类型`

- 区别:

  1. 存储位置不同
     - 基础数据类型(6 种) 存在栈内存中
     - 引用数据类型：存在堆内存中
  2. 大小和存放的区别
     - 基础数据类型：占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储
     - 引用数据类型： 占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其索引

## 判断数据类型：typeof 和 instanceof

::: tip typeof

- `typeof` 对于基本类型，除了 `null` 都可以显示正确的类型
- `typeof` 对于对象，除了函数都会显示 `object`
- 主要用于判断数据是不是基本数据类型：`String`、`Number`、`Object`、`Null`、`Undefined`，但是无法判断出 function（有些浏览器会出错）、array、regExp

```js
console.log(typeof '') // string
console.log(typeof []) // object
console.log(typeof {}) // object
console.log(typeof 1) // number
console.log(typeof null) // object
console.log(typeof undefined) // undefined
console.log(typeof true) // boolean
console.log(typeof function() {}) // function
console.log(typeof /\d/) // object
```

:::

::: tip instanceof

- 主要的目的是用来检测`引用类型`，判断 `Array` 和 `RegExp`，无法准确判断 Function
- `A对象 instanceof B对象` : 判断 A 对象原型链上 是否有 B 对象原型 ！！！
- `instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`

```js
console.log([] instanceof Array) //true
console.log({} instanceof Object) //true
console.log(/\d/ instanceof RegExp) //true
console.log(function() {} instanceof Object) //true
console.log(function() {} instanceof Function) //true

console.log('' instanceof String) //false
console.log(1 instanceof Number) //false
```

:::

::: tip Object.prototype.toString
这是对象的一个原生原型扩展函数，用来精确的区分数据类型

```js
var type = Object.prototype.toString
console.log(type.call('')) // [object String]
console.log(type.call([])) // [object Array]
console.log(type.call({})) // [object Object]
console.log(type.call(false)) // [object Boolean]
console.log(type.call(null)) // [object Null]
console.log(type.call(undefined)) // [object Undefined]
console.log(type.call(function() {})) // [object Function]
```

:::

## js 的内置对象有哪些

> 内置对象概念：js 已经创建好了，你不用自己再创建的对象（免去 new 的步骤），直接就可以调用

- 其他对象：`Function`、`Arguments`、`Math`、`Date`、`RegExp`、`Error`
- 数据封装类对象：`Object`、`Array`、`Boolean`、`Number` 和 `String`

## null，undefined 的区别

- `null`

  1. 表示一个对象被定义了，值为“空值”
  2. 是一个对象(空对象, 没有任何属性和方法)

- `undefined`

  1.  表示不存在这个值。
  2.  是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 `undefined`
  3.  例如变量被声明了，但没有赋值时，就等于 `undefined`

---

- null 表示一个值被定义了，定义为“空值”；
- undefined 表示根本不存在定义。
- 所以设置一个值为 null 是合理的，如 objA.valueA = null;
- 但设置一个值为 undefined 是不合理的

```js
typeof null // object
typeof undefined // undefined
null == undefined // true
null === undefined // false
```

::: danger
在验证 `null` 时，一定要使用　`===` ，因为 `==`无法分别 `null` 和 `undefined`
:::

## == 和 ===区别，什么情况用 ==

1. == 叫做 `相等运算符` ，=== 叫做 `严格运算符`
2. 使用 `==` 的时候，如果 2 边的值类型不一致，会自动转换为同一类型在比较
   `如： 1 == '1' // true`
3. 使用 `===` 的时候，不会进行类型转换，必须类型一致，值也一致，才返回 true

## 创建对象的几种方式

1. 对象字面量的方式
2. 用 `function` 来模拟无参的构造函数
3. 用 `function` 来模拟参构造函数来实现（用 `this` 关键字定义构造的上下文属性）
4. 用工厂方式来创建（内置对象）
5. 用原型方式来创建
6. 用混合方式来创建

::: details 查看详细的创建代码

1. 对象字面量

```js
let person = { name: 'Jioho', sex: 'man', age: 22 }
```

2. 用 `function` 来模拟无参的构造函数

```js
function Person() {}
// 定义一个function，如果使用new"实例化"
// 该function可以看作是一个Class
var person = new Person()
person.name = 'Jioho'
person.age = '22'
person.work = function() {
  console.log(this.name + ' is codinig')
}
person.work() // jioho is coding
```

3. 用 function 来模拟参构造函数来实现

```js
// 用this关键字定义构造的上下文属性
function Person(name, age, skill) {
  this.name = name //this作用域：当前对象
  this.age = age
  this.skill = skill
  this.word = function() {
    console.log(this.name + ' skill is ' + this.skill)
  }
}

//实例化、创建对
var author = new Person('Jioho', 25, 'coding')象
author.word() // Jioho skill is coding
```

4. 用工厂方式来创建（内置对象）

```js
var dog = new Object()
dog.name = '旺财'
dog.age = 3
dog.shout = function() {
  console.log('我是' + wcDog.name + ',汪汪汪......')
}
dog.shout()
```

5. 用原型方式来创建

```js
function Dog() {}
Dog.prototype.name = '旺财'
Dog.prototype.shout = function() {
  console.log('我是' + wcDog.name + ',汪汪汪......')
}
var wangcai = new Dog()
wangcai.shout()
```

6. 用混合方式来创建

```js
function Car(name, price) {
  this.name = name
  this.price = price
}
Car.prototype.sell = function() {
  console.log('我是' + this.name + '，我现在卖' + this.price + '万元')
}
var camry = new Car('凯美瑞', 27)
camry.sell()
```

:::

## let var const 区别

- 作用域

  - `let` 作用域被限制在块级中的变量、语句或者表达式
  - `var` 作用域限制在其声明位置的上下文中，而非声明变量总是全局的
  - `const` 声明创建一个值的只读引用 (即指针)

- 变量提升

  - `let` 不存在变量提升，存在暂时性死区，咋子赋值之前使用该变量会报错
  - `var` 存在变量提升，如果在变量赋值之前使用该变量拿到的值是 undefined
  - `const` 不存在变量提示，提前使用变量会报错

::: details 查看变量提升的示例

```js
;(function() {
  console.log(testLet) // Cannot access 'testLet' before initialization
  console.log(testVar) // undefined
  console.log(testConst) // Uncaught ReferenceError: Cannot access 'testConst' before initialization
  let testLet = 'testLet'
  var testVar = 'testVar'
  const testConst = 'testConst'
})()
```

:::

- 可变性

  - `let` 变量可以重新赋值
  - `var` 变量可以重新赋值
  - `const` 变量不可变，如果变量是复合类型（对象），改变复合对象中的某一项可以改变

```js
const anthor = { name: 'Jioho' }
anthor = 'Jioho' // Uncaught TypeError: Assignment to constant variable
anthor.name = 'Jioho_chen' // 成功
```

::: tip let、var 、const 使用

1. let 命令不存在变量提升，如果在 let 前使用 var，会导致报错
2. 如果块区中存在 let 和 const 命令，就会形成封闭作用域
3. 不允许重复声明，因此，不能在函数内部重新声明参数

::: details 查看示例

```js
function fn() {
  var _fn = 1
  var _fn = 2
  console.log(_fn) // 2
}

// 报错理由：3 - 不允许重复声明
function fn() {
  // 报错
  let _fn = 1
  let _fn = 2

  // 报错
  const _fn = 1
  const _fn = 2

  // 报错
  let _fn = 1
  var _fn = 2
}

// 报错理由：3 - 不允许重复声明
function fn(name) {
  // 报错
  let name = 'Jioho'
  const name = 'Jioho'

  // 正常访问！
  var name = 'Jioho'

  // 正常访问
  let a = () => {
    let name = 'Jioho'
  }
}

function fn() {
  let name = 'Jioho'
  const anthor = name

  console.log(name, anthor)
}
```

:::

## 描述一下 `this`

1. 函数执行的上下文，可以通过 `apply`，`call`，`bind` 改变 this 的指向。
2. 对于匿名函数或者直接调用的函数来说，this 指向全局上下文（浏览器为 window，NodeJS 为 global），剩下的函数调用，那就是谁调用它，this 就指向谁。
3. 当然还有 es6 的箭头函数，`箭头函数`的指向取决于该箭头函数声明的位置，在哪里声明，this 就指向哪里

## `apply`，`call`，`bind` 区别

1. `call` 和 `apply` 都是为了解决改变 `this` 的指向。作用都是相同的，只是传参的方式不同
2. 除了第一个参数外，`call` 可以接收一个参数列表，`apply` 只接受一个参数数组
3. `bind` 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并不会立刻执行

## 箭头函数的特点

```js
function fn() {
  return () => {
    return () => {
      console.log(this)
    }
  }
}
console.log(fn()()())
```

::: tip

- 箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 fn 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变

- 由于箭头函数没有自己的 this，所以当然也就不能用 call()、apply()、bind()这些方法去改变 this 的指向。

:::
