(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{356:function(t,s,o){"use strict";o.r(s);var e=o(25),a=Object(e.a)({},(function(){var t=this,s=t.$createElement,o=t._self._c||s;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"js-进阶"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#js-进阶"}},[t._v("#")]),t._v(" JS 进阶")]),t._v(" "),o("h2",{attrs:{id:"闭包-进阶必问！"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#闭包-进阶必问！"}},[t._v("#")]),t._v(" 闭包 进阶必问！")]),t._v(" "),o("p",[o("strong",[t._v("概念：")])]),t._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[t._v("什么是闭包")]),t._v(" "),o("ul",[o("li",[t._v("闭包就是能够"),o("code",[t._v("读取其他函数内部变量的函数")])]),t._v(" "),o("li",[t._v("创建闭包的最常见的方式就是在"),o("code",[t._v("一个函数内创建另一个函数")]),t._v("，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域")])])]),t._v(" "),o("h2",{attrs:{id:"common-js-和-es6-中模块引入的区别？"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#common-js-和-es6-中模块引入的区别？"}},[t._v("#")]),t._v(" common.js 和 es6 中模块引入的区别？")]),t._v(" "),o("p",[t._v("CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。在使用上的差别主要有：")]),t._v(" "),o("ul",[o("li",[t._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。")]),t._v(" "),o("li",[t._v("CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。")]),t._v(" "),o("li",[t._v("CommonJs 是单个值导出，ES6 Module 可以导出多个")]),t._v(" "),o("li",[t._v("CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层")]),t._v(" "),o("li",[t._v("CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined")])]),t._v(" "),o("h2",{attrs:{id:"谈一下-js-的类型转换"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#谈一下-js-的类型转换"}},[t._v("#")]),t._v(" 谈一下 JS 的类型转换")]),t._v(" "),o("p",[t._v("JS 的类型转换分为："),o("code",[t._v("显式类型转换")]),t._v("、"),o("code",[t._v("隐式类型转换")])])])}),[],!1,null,null,null);s.default=a.exports}}]);