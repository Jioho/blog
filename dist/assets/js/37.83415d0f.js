(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{431:function(t,a,r){"use strict";r.r(a);var s=r(17),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"virtual-dom-的优势在哪里"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom-的优势在哪里"}},[t._v("#")]),t._v(" Virtual Dom 的优势在哪里")]),t._v(" "),r("h2",{attrs:{id:"「virtual-dom-的优势」"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#「virtual-dom-的优势」"}},[t._v("#")]),t._v(" 「Virtual Dom 的优势」")]),t._v(" "),r("p",[t._v("其实这道题目面试官更想听到的答案不是上来就说「直接操作/频繁操作 DOM 的性能差」，如果 DOM 操作的性能如此不堪，那么 jQuery 也不至于活到今天。所以面试官更想听到 VDOM 想解决的问题以及为什么频繁的 DOM 操作会性能差。")]),t._v(" "),r("h2",{attrs:{id:"首先我们需要知道"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#首先我们需要知道"}},[t._v("#")]),t._v(" 首先我们需要知道")]),t._v(" "),r("p",[t._v("DOM 引擎、JS 引擎 相互独立，但又工作在同一线程（主线程）")]),t._v(" "),r("p",[t._v("JS 代码调用 DOM API 必须 挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，\n引擎间切换的单位代价将迅速积累若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。")]),t._v(" "),r("h2",{attrs:{id:"其次是-vdom-和真实-dom-的区别和优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#其次是-vdom-和真实-dom-的区别和优化"}},[t._v("#")]),t._v(" 其次是 VDOM 和真实 DOM 的区别和优化")]),t._v(" "),r("ol",[r("li",[t._v("虚拟 DOM 不会立马进行排版与重绘操作")]),t._v(" "),r("li",[t._v("虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多 DOM 节点排版与重绘损耗")]),t._v(" "),r("li",[t._v("虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部")])])])}),[],!1,null,null,null);a.default=v.exports}}]);